<#
.SYNOPSIS
   Invokes the CWC powershell module library
   
   Copyright (c) Citrix Systems, Inc. All Rights Reserved.
.DESCRIPTION
  Requires the CWC library attached in a ZIP file to the script
  Extracts the zip to %temp%\citrix
  Copies the CWC modules to C:\Program Files (x86)\Common Files\Modules
  Updates the environment variable PSModulePath to include C:\Program Files (x86)\Common Files\Modules

.Parameter CWCPath
    The complete path to the extracted CWC Library  
#>
[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)][string] $CWCName = "cwc.zip",
    [Parameter(Mandatory=$false)][string] $CWCBasePath = (Join-Path -Path $ENV:Temp -ChildPath "Citrix"),
    [Parameter(Mandatory=$false)][string] $CWCModulePath = (Join-Path -Path $ENV:programfiles -ChildPath "Common Files\Modules\CWC")
)

function Unzip-File { 
 
    <# 
    .SYNOPSIS 
        Unzip-File is a function which extracts the contents of a zip file. 
 
    .DESCRIPTION 
        Unzip-File is a function which extracts the contents of a zip file specified via the -File parameter to the 
    location specified via the -Destination parameter. This function first checks to see if the .NET Framework 4.5 
    is installed and uses it for the unzipping process, otherwise COM is used. 
 
    .PARAMETER File 
        The complete path and name of the zip file in this format: C:\zipfiles\myzipfile.zip  
  
    .PARAMETER Destination 
        The destination folder to extract the contents of the zip file to. If a path is no specified, the current path 
    is used. 
 
    .PARAMETER ForceCOM 
        Switch parameter to force the use of COM for the extraction even if the .NET Framework 4.5 is present. 
 
    .EXAMPLE 
        Unzip-File -File C:\zipfiles\AdventureWorks2012_Database.zip -Destination C:\databases\ 
 
    .EXAMPLE 
        Unzip-File -File C:\zipfiles\AdventureWorks2012_Database.zip -Destination C:\databases\ -ForceCOM 
 
    .EXAMPLE 
        'C:\zipfiles\AdventureWorks2012_Database.zip' | Unzip-File 
 
    .EXAMPLE 
        Get-ChildItem -Path C:\zipfiles | ForEach-Object {$_.fullname | Unzip-File -Destination C:\databases} 
    #> 
 
    [CmdletBinding()] 
    param ( 
        [Parameter(Mandatory=$true,  
                   ValueFromPipeline=$true)] 
        [ValidateScript({ 
            If ((Test-Path -Path $_ -PathType Leaf) -and ($_ -like "*.zip")) { 
                $true 
            } 
            else { 
                Throw "$_ is not a valid zip file. Enter in 'c:\folder\file.zip' format" 
            } 
        })] 
        [string]$File, 
 
        [ValidateNotNullOrEmpty()] 
        [ValidateScript({ 
            If (Test-Path -Path $_ -PathType Container) { 
                $true 
            } 
            else { 
                Throw "$_ is not a valid destination folder. Enter in 'c:\destination' format" 
            } 
        })] 
        [string]$Destination = (Get-Location).Path, 
 
        [bool]$ForceCOM 
    ) 
 
 
    If (-not $ForceCOM -and ($PSVersionTable.PSVersion.Major -ge 3) -and 
       ((Get-ItemProperty -Path "HKLM:\Software\Microsoft\NET Framework Setup\NDP\v4\Full" -ErrorAction SilentlyContinue).Version -like "4.5*" -or 
       (Get-ItemProperty -Path "HKLM:\Software\Microsoft\NET Framework Setup\NDP\v4\Client" -ErrorAction SilentlyContinue).Version -like "4.5*")) { 
 
        Write-Verbose -Message "Attempting to Unzip $File to location $Destination using .NET 4.5" 
 
        try { 
            [System.Reflection.Assembly]::LoadWithPartialName("System.IO.Compression.FileSystem") | Out-Null 
            [System.IO.Compression.ZipFile]::ExtractToDirectory("$File", "$Destination") 
        }
        catch { 
            Write-Warning -Message "Unexpected Error. Error details: $_.Exception.Message" 
        } 
 
 
    } 
    else { 
 
        Write-Verbose -Message "Attempting to Unzip $File to location $Destination using COM" 
 
        try { 
            $shell = New-Object -ComObject Shell.Application 
            $shell.Namespace($destination).copyhere(($shell.NameSpace($file)).items()) 
        } 
        catch { 
            Write-Warning -Message "Unexpected Error. Error details: $_.Exception.Message" 
        } 
 
    } 
 
}


# Check if user is administrator
Write-Host "Checking permissions"
If (-not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
	Throw "You must be administrator in order to execute this script"
}

#verify destination, wipe any exiting copy and extract CWC library
Write-Verbose "Verifying destination path $CWCBasePath"
if (Test-Path "filesystem::$CWCBasePath") { 
    Write-Verbose "filesystem::$CWCBasePath Exists" 
    if (Test-Path "filesystem::$CWCBasePath\CWC") {
        Write-Verbose "filesystem::$CWCBasePath Exists, Removing existing CWC" 
        Remove-Item "$CWCBasePath\CWC" -Force -Recurse -ErrorAction SilentlyContinue
    }
} else { Write-Verbose "$CWCBasePath doesn't exist, creating ..."; new-item $CWCBasePath -type directory }

if (!(Test-Path "filesystem::$CWCBasePath")) {throw "filesystem::$CWCBasePath doesn't exist and fails to be created" }

$curPath = Split-Path $script:MyInvocation.MyCommand.Path
$file = Join-Path -Path $curPath -ChildPath $CWCName
Unzip-File -File $file -Destination $CWCBasePath

#Create modules folder folder and wipe any existing copy
Write-Host "Creating $CWCModulePath"
new-item "$CWCModulePath" -type directory -Force
if (!(Test-Path $CWCModulePath)) {throw "$CWCModulePath doesn't exist and fails to be created" }
# copy CWC modules to common files dir
Copy-Item -Path "$CWCBasePath\CWC\Modules\*" -Destination "$CWCModulePath" -Recurse -Force

#update PSModulePath
$CurrentValue = [Environment]::GetEnvironmentVariable("PSModulePath", "Machine")

If (-not $CurrentValue.ToLower().Contains($CWCModulePath.ToLower())) {
	Write-Host "Adding CWC modules"
    $CurrentValue += ";$CWCModulePath"
    #Set machine path for all users
    [Environment]::SetEnvironmentVariable("PSModulePath", $CurrentValue, "Machine")
    #Set environment variable so it works immediatly (doesn't seem to work for CLM service account, nor does setting user or process)
    $env:PSModulePath = $env:PSModulePath + ";$CWCModulePath"
} Else {
	Write-Host "CWC modules are already configured, skipping..."
}